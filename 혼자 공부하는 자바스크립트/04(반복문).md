# Chapter 04. 반복문

## 04-1 배열

- 배열 : 여러 자료를 묶어서 활용할 수 있는 특수한 자료

```jsx
[요소, 요소, 요소, ..., 요소]
```

### 배열 요소에 접근하기

```jsx
배열[인덱스];
```

### 배열 요소 개수 확인하기

```jsx
배열.length;
```

### 배열 뒷부분에 요소 추가하기

```jsx
배열.push(요소);
```

```jsx
const todos = ["우유 구매", "업무 매일 확인하기", "필라테스 수업"];
undefined >
  todos(3)[("우유 구매", "업무 매일 확인하기", "필라테스 수업")] >
  todos.push("저녁 식사 준비하기");
4 > todos.push("피아노 연습하기");
5 >
  todos(5)[
    ("우유 구매",
    "업무 매일 확인하기",
    "필라테스 수업",
    "저녁 식사 준비하기",
    "피아노 연습하기")
  ];
```

### 배열 요소 제거하기

1. 인덱스를 기반으로 제거
2. 값을 기반으로 제거

```jsx
배열.splice(인덱스, 제거할 요소의 개수)
```

```jsx
> const itemsA = ['사과', '배', '바나나']
undefined

> itemsA.splice(2, 1)
["바나나"]

> itemsA
(2) ["사과", "베"]
```

### 값으로 요소 제거하기

```jsx
const 인덱스 = 배열.indexOf(요소);
배열.splice(인덱스, 1);
```

```jsx
> const itemsB = ['사과', '배', '바나나']
undefined

> const index = itemsB.indexOf('바나나')
Undefined

> index
2

> itemsB.splice(index, 1)
["바나나"]

> itemsB
(2) ["사과", "배"]

> itemsB.indexOf('바나나')
-1
```

### 배열의 특정 위치에 요소 추가하기

```jsx
배열.splice(인덱스, 0, 요소);
```

```jsx
> const itemsD = ["사과", "귤", "바나나", "오렌지"]
undefined

> itemsD.splice(1, 0, "양파")
[]

> itemsD
(5) ["사과", "양파", "귤", "바나나", "오렌지"]
```

- 비파괴적 처리 : 처리 후에 원본 내용이 변경되지 않는다.
- 파괴적 처리 : 처리 후에 원본 내용이 변경됩니다.

### 비파괴적 처리

```jsx
> const a = '안녕'
> const b = '하세요'

> const c = a + b

> c
"안녕하세요"

> a
"안녕"
> b
"하세요"
```

### 파괴적 처리

```jsx
> const array = ["사과", "배", "바나나"]

> array.push("귤")

> array
(4) ["사과", "배", "바나나", "귤"]
```

- 결과가 기본 자료형이면 메모리를 조금만 차지하기 때문에 원본과 결과를 모두 메모리에 저장해도 크게 무리가 없었습니다. 하지만 배열처럼 크기가 어느 정도인지 모르는 대상의 원본과 결과를 모두 메모리에 저장하는 것은 위험할 수 있습니다. 그래서 배열과 같이 거대해질 수 있는 자료는 메모리를 절약할 수 있게 대부분 **파괴적 처리**로 이루어졌습니다. 다만 파괴적 처리는 메모리를 절약할 수 있지만, 원본이 사라지기 때문에 위험할 수 있습니다.
- 따라서 메모리가 여유로운 현대의 프로그래밍 언어와 라이브러리는 자료 보호를 위해서 대부분 **비파괴적 처리**를 합니다.
